

# This file was *autogenerated* from the file fastmt_solver.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_624 = Integer(624); _sage_const_32 = Integer(32); _sage_const_1 = Integer(1); _sage_const_31 = Integer(31); _sage_const_16 = Integer(16); _sage_const_3 = Integer(3); _sage_const_30 = Integer(30)
import tqdm
import time

from fastmt import MT19937
import numpy

load("fill_matrix.spyx")

class MT19937Solver:
    def __init__(self):
        self.model = MT19937()
        self.observed = []

    def submit(self, bits, value):
        bit_expressions = self.model.getrandbits(bits).mat[:bits,:]

        # cannot extend observed
        # this call will have simply advanced the state
        if value is None:
            return

        for i, expr in zip(range(bits), bit_expressions):
            if value[i] is not None:
                expr = numpy.unpackbits(expr.view(numpy.uint8), bitorder='little')
                self.observed.append((expr, value[i]))
        
    def v2n(self, vec):
        acc = _sage_const_0 
        for i, v in enumerate(vec):
            acc += _sage_const_2 **i * int(v)
        return acc

    def solve(self):
        size = self.model.N * self.model.W
        rows = []
        observed_values = []
        observed = vector(GF(_sage_const_2 ), len(self.observed))
        print("Constructing rows and observed values")
        shape = (int(len(observed)),int(_sage_const_624 *_sage_const_32 ))
        rows = numpy.zeros(shape=shape, dtype=numpy.uint32)
        for i,(row, value) in tqdm.tqdm(enumerate(self.observed)):
            observed[i] = value
            rows[i] = row
        # Create Matrix
        start = time.time()
        M = Matrix(GF(_sage_const_2 ), len(self.observed), size)
        print("Filling Matrix...")
        #for i,(row, value) in tqdm.tqdm(enumerate(self.observed)):
        #    #for j in range(len(row)):
        #    #    M[i,j] = row[j]
        #    M.set_row(i,row)
        #    #fill_matrix_row(M, i, len(row), row)
        #    eqns.append(row)
        #    #observed[i] = value
        fill_matrix(M, rows)
        print("Filled Matrix:", time.time() - start)
        print("Solving Matrix for observed vector")
        self.M = M
        start = time.time()
        solution = M  * BackslashOperator() * observed
        print("Computed solution:", time.time() - start)
        print("Converting to numbers...")
        res = []
        for i in range(_sage_const_624 ):
            res.append(self.v2n(solution[_sage_const_32 *i:_sage_const_32 *(i+_sage_const_1 )]))
        return res

def test2():
    import random
    mrand = MT19937Solver()
    rand = random.Random(int(_sage_const_1 ))
    initial_state = rand.__getstate__()[_sage_const_1 ][:-_sage_const_1 ]
    #b = rand.choices([0,1,2,3], weights=[1,1,1,1])[0]
    b = rand.getrandbits(_sage_const_32 )
    mrand.submit(_sage_const_32 ,[None]*_sage_const_31  + [b>>_sage_const_31 ])
    for i in tqdm.tqdm(range(_sage_const_624 *_sage_const_16 )):
        #b = (rand.getrandbits(32) >> 30) & 3
        #b1 = b >> 1
        #b2 = b & 1
        #_ = (rand.getrandbits(32) >> 30) & 3
        b = rand.choices([_sage_const_0 ,_sage_const_1 ,_sage_const_2 ,_sage_const_3 ], weights=[_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ])[_sage_const_0 ]
        #mrand.submit(32, [None]*30+[b2, b1])
        mrand.submit(_sage_const_32 , [None]*_sage_const_30  + [b&_sage_const_1 ,b>>_sage_const_1 ])
        mrand.submit(_sage_const_32 , None)
    result = mrand.solve()
    for i in range(len(initial_state)):
        print(initial_state[i], result[i])

if __name__ == "__main__":
    test2()

